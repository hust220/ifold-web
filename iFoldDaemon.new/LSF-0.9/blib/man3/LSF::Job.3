.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LSF::Job 3"
.TH LSF::Job 3 "2002-04-11" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
LSF::Job \- create and manipulate LSF jobs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use LSF::Job;
.PP
use LSF::Job RaiseError => 0, PrintError => 1, PrintOutput => 0;
.PP
$job = LSF::Job\->new(123456);
.PP
\&...
.PP
$job = LSF::Job\->submit(\-q => 'default'
                       ,\-o => '/dev/null'
                       ,\*(L"echo hello\*(R");
.PP
$job2 = LSF::Job\->submit(\-q => 'default'
                        ,\-o => '/home/logs/output.txt'
                        ,\*(L"echo world!\*(R");
.PP
@jobs = LSF::Job\->jobs( \-J => \*(L"/mygroup/*\*(R" );
.PP
$job2\->modify(\-w => \*(L"done($job)\*(R" );
.PP
$job2\->del(\-n => 1);
.PP
\&...
.PP
$job\->\fItop()\fR;
.PP
$job\->\fIbottom()\fR;
.PP
$exit = \f(CW$job\fR\->history\->exit_status;
.PP
\&... etc ...
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`LSF::Job\*(C'\fR is a wrapper arround the \s-1LSF\s0 b* commands used to submit and
manipulate jobs. for a description of how the \s-1LSF\s0 commands work see the 
man pages of:
.PP
.Vb 1
\&    bsub bbot bchkpnt bkill bmig bmod brequeue brestart bresume bstop bswitch btop
.Ve
.SH "INHERITS FROM"
.IX Header "INHERITS FROM"
\&\fB\s-1LSF\s0\fR
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "new ( [\s-1NUM\s0] )" 4
.IX Item "new ( [NUM] )"
$job = LSF::Job\->new(123456);
.Sp
Creates a new \f(CW\*(C`LSF::Job\*(C'\fR object.
.Sp
Required argument is a \s-1LSF\s0 jobid. This does not *have* to exist in the system
but would probably be a good idea!
.IP "submit ( [ [\s-1ARGS\s0] ], [\s-1COMMAND_STRING\s0] )" 4
.IX Item "submit ( [ [ARGS] ], [COMMAND_STRING] )"
$job = LSF::Job\->submit(\-q => 'default'
                       ,\-o => '/dev/null'
                       ,\*(L"echo hello\*(R");
.Sp
Creates a new \f(CW\*(C`LSF::Job\*(C'\fR object.
.Sp
Arguments are the \s-1LSF\s0 parameters normally passed to 'bsub'.
.Sp
Required parameter is the command line (as a string) that you want to execute.
.IP "jobs ( [\s-1ARGS\s0] )" 4
.IX Item "jobs ( [ARGS] )"
@jobs = LSF::Job\->jobs( \-J => \*(L"/mygroup/*\*(R" );
.Sp
Creates an array of LSF::Job objects corresponding to jobs that match the query
.Sp
Arguments are the \s-1LSF\s0 parameters normally passed to 'bjobs'.
.SH "METHODS"
.IX Header "METHODS"
.IP "$job\->\fIid()\fR (or object in string context)" 4
.IX Item "$job->id() (or object in string context)"
\&\f(CW\*(C`id\*(C'\fR returns the jobid of the \s-1LSF\s0 Job. This is particularly useful when
building up job interdependencies
.IP "$job\->history" 4
.IX Item "$job->history"
Returns a LSF::JobHistory object with information about the \s-1LSF\s0 job. 
See the LSF::JobHistory perldoc page.
.IP "$job\->bottom" 4
.IX Item "$job->bottom"
Moves the \s-1LSF\s0 job to the bottom of its queue. See the bbot man page.
Returns true on success, false on failure. Sets $? and $@;
.IP "$job\->checkpoint" 4
.IX Item "$job->checkpoint"
Checkpoints a checkpointable job. See the bchkpnt man page.
Returns true on success, false on failure. Sets $? and $@;
.IP "$job\->delete( [\s-1ARGS\s0] )" 4
.IX Item "$job->delete( [ARGS] )"
*** Deprecated in \s-1LSF\s0 5.0. Use kill instead. ***
.Sp
Deletes the \s-1LSF\s0 job from the system. See the bdel man page.
Returns true on success, false on failure. Sets $? and $@;
.IP "$job\->kill" 4
.IX Item "$job->kill"
Kills the \s-1LSF\s0 job. See the bkill man page.
Returns true on success, false on failure. Sets $? and $@;
.IP "$job\->migrate" 4
.IX Item "$job->migrate"
Migrates the \s-1LSF\s0 job. See the bmigrate man page.
Returns true on success, false on failure. Sets $? and $@;
.IP "$job\->modify( [\s-1ARGS\s0] )" 4
.IX Item "$job->modify( [ARGS] )"
Modifies the \s-1LSF\s0 job. See the bmod man page.
Since the objects are overloaded to return the job id when used in string 
context this allows easy build up of job dependancies e.g.
Returns true on success, false on failure. Sets $? and $@;
.Sp
$job3\->modify(\-w => \*(L"done($job1) && done($job2)\*(R" );
.IP "$job\->restart" 4
.IX Item "$job->restart"
Restarts a checkpointed job. See the brestart man page.
Returns true on success, false on failure. Sets $? and $@;
.IP "$job\->resume" 4
.IX Item "$job->resume"
Resumes a suspended job. See the bresume man page.
Returns true on success, false on failure. Sets $? and $@;
.IP "$job\->run" 4
.IX Item "$job->run"
Starts the \s-1LSF\s0 job now. See the brun man page.
Returns true on success, false on failure. Sets $? and $@;
.IP "$job\->stop" 4
.IX Item "$job->stop"
Stops the \s-1LSF\s0 job. See the bstop man page.
Returns true on success, false on failure. Sets $? and $@;
.IP "$job\->switch( [\s-1ARGS\s0] )" 4
.IX Item "$job->switch( [ARGS] )"
Switches the \s-1LSF\s0 job between \s-1LSF\s0 queues. See the bswitch man page.
Returns true on success, false on failure. Sets $? and $@;
.IP "$job\->top" 4
.IX Item "$job->top"
Moves the \s-1LSF\s0 job to the top of its queue. See the btop man page.
Returns true on success, false on failure. Sets $? and $@;
.SH "BUGS"
.IX Header "BUGS"
The use of the '\-l' flag of the \s-1LSF\s0 command lines can be considered a bug.
Using \s-1LSF\s0 job names with non alphabetic characters can also be considered a bug.
Otherwise, please report them.
.SH "HISTORY"
.IX Header "HISTORY"
The \fBLSF::Batch\fR module on cpan didn't compile easily on all platforms i wanted.
The \s-1LSF\s0 \s-1API\s0 didn't seem very perlish either. As a quick fix I knocked these
modules together which wrap the \s-1LSF\s0 command line interface. It was enough for
my simple usage. Hopefully they work in a much more perly manner.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1LSF\s0,
LSF::JobHistory,
bsub,
bhist,
bswitch,
bdel,
bkill,
bstop,
bmod,
btop,
bbot,
brun
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Southern (mark_southern@merck.com)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002, Merck & Co. Inc. All Rights Reserved.
This module is free software. It may be used, redistributed
and/or modified under the terms of the Perl Artistic License
(see http://www.perl.com/perl/misc/Artistic.html)
