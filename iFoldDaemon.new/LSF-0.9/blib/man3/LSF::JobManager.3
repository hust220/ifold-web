.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LSF::JobManager 3"
.TH LSF::JobManager 3 "2002-04-11" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
LSF::JobManager \- submit and wait for a set of LSF Jobs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use LSF RaiseError => 0, PrintError => 1, PrintOutput => 0;
\&    use LSF::JobManager;
.Ve
.PP
.Vb 1
\&    my $m = LSF::JobManager->new(-q=>'small');
.Ve
.PP
.Vb 2
\&    my $job = $m->submit("echo hello");
\&    $m->submit("echo world");
.Ve
.PP
.Vb 3
\&    for my $job ($m->jobs){
\&        $job->top;
\&    }
.Ve
.PP
.Vb 2
\&    $m->wait_all_children( history => 1 );
\&    print "All children have completed!\en";
.Ve
.PP
.Vb 3
\&    for my $job ($m->jobs){ # much quicker if history is pre-cached
\&        print STDERR "$job exited non zero\en" if $job->history->exit_status != 0;
\&    }
.Ve
.PP
.Vb 1
\&    $m->clear; # clear out the job manager to reuse.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`LSF::JobManager\*(C'\fR provides a simple mechanism to submit a set of command lines
to the \s-1LSF\s0 Batch system and then wait for them all to finish in a blocking
(efficient) manner. 
.SH "INHERITS FROM"
.IX Header "INHERITS FROM"
\&\fB\s-1LSF\s0\fR
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "new ( [ \s-1ARGS\s0 ] )" 4
.IX Item "new ( [ ARGS ] )"
$manager = LSF::JobManager\->new(\-q=>'small'
                               ,\-m=>'mymachine');
.Sp
Creates a new \f(CW\*(C`LSF::JobManager\*(C'\fR object.
.Sp
Any parameters are used as defaults passed to the submit method.
.SH "METHODS"
.IX Header "METHODS"
.IP "$manager\->submit( [ [ \s-1ARGS\s0 ] ], [\s-1CMD\s0] )" 4
.IX Item "$manager->submit( [ [ ARGS ] ], [CMD] )"
Submits a command line to \s-1LSF\s0. This is a wrapper around the LSF::Job\->submit
call. The required argument is the command line to submit. Optional arguments
override the defaults given to \f(CW\*(C`new\*(C'\fR. The submitted LSF::Job object is returned
on success, otherwise undef is returned, $? and $@ set. See \f(CW\*(C`LSF::Job\*(C'\fR
.IP "$manager\->wait_all_children( [ depend => \s-1DEPENDANCY\s0, history => 1 ] )" 4
.IX Item "$manager->wait_all_children( [ depend => DEPENDANCY, history => 1 ] )"
Waits for all previously submitted \s-1LSF\s0 Jobs to complete in a blocking manner.
.Sp
If a dependancy expression is provided then this is used in preference to 
an autogenerated dependancy based on the job id's of all the submitted jobs.
In conjunction with named jobs ( the \-J flag ) this can be used to get around
the shell arg length limit which can be hit by extremely long dependancy 
expressions. See the bsub documentation for details of job names and 
depenancy expressions.
.Sp
If the history flag is used to pass a true value then after all jobs have 
completed the history of each job is fetched in batch. It is much quicker
this way than fetching each job history separately. The time taken is still 
significant however. If you do not intend to check the exit status or the
command line or any other property of the Job::History object then it is worth
passing a false value and avoiding the overhead.
.IP "$manager\->params( [ [ \s-1PARAMS\s0 ] ] )" 4
.IX Item "$manager->params( [ [ PARAMS ] ] )"
Sets the default submission parameters.
.IP "$manager\->\fIjobs()\fR" 4
.IX Item "$manager->jobs()"
Returns an array of the submitted LSF::Job objects.
.IP "$manager\->\fIclear()\fR" 4
.IX Item "$manager->clear()"
Empties the job array so that the manager can be reused. 
Returns an array of the jobs removed.
.SH "HISTORY"
.IX Header "HISTORY"
The \fBLSF::Batch\fR module on cpan didn't compile easily on all platforms i wanted.
The \s-1LSF\s0 \s-1API\s0 didn't seem very perlish either. As a quick fix I knocked these
modules together which wrap the \s-1LSF\s0 command line interface. It was enough for
my simple usage. Hopefully they work in a much more perly manner.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1LSF\s0,
LSF::Job
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Southern (mark_southern@merck.com)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002, Merck & Co. Inc. All Rights Reserved.
This module is free software. It may be used, redistributed
and/or modified under the terms of the Perl Artistic License
(see http://www.perl.com/perl/misc/Artistic.html)
